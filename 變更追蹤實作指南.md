# WPF 資料變更追蹤實作指南

## 概述

本文件說明如何在 WPF + Prism 專案中實作高效能的資料變更追蹤機制，適用於需要處理大量資料（數萬至數十萬筆）的場景。

## 核心概念

### 問題背景

在傳統的資料編輯場景中，使用者需要手動勾選 checkbox 來標記要儲存的資料。這種方式增加了操作步驟，降低了使用者體驗。

### 解決方案

實作自動變更追蹤機制，當資料被修改時自動標記為「髒資料」(Dirty)，並支援以下功能：

1. **自動偵測變更**：當屬性值改變時，自動標記該物件為 `IsDirty = true`
2. **還原偵測**：當值改回原始值時（A → B → A），自動標記為 `IsDirty = false`
3. **記憶體最佳化**：只有被修改過的物件才會佔用額外記憶體
4. **高效能查詢**：透過 LINQ 快速找出所有被修改的資料

---

## 實作步驟

### 步驟 1：建立 TrackableBindableBase 基底類別

這個類別繼承自 Prism 的 `BindableBase`，並加入變更追蹤邏輯。

```csharp
using Prism.Mvvm;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace YourProject.Core
{
    public class TrackableBindableBase : BindableBase
    {
        // 儲存原始值的字典，只有被修改過的屬性才會出現在這裡
        private Dictionary<string, object> _originalValues;

        private bool _isDirty;
        public bool IsDirty
        {
            get { return _isDirty; }
            private set { SetProperty(ref _isDirty, value); }
        }

        // 覆寫 Prism 的 SetProperty 方法，攔截所有屬性變更
        protected override bool SetProperty<T>(ref T storage, T value, 
            [CallerMemberName] string propertyName = null)
        {
            T oldValue = storage;
            bool isChanged = base.SetProperty(ref storage, value, propertyName);

            if (isChanged)
            {
                UpdateDirtyState(propertyName, oldValue, value);
            }

            return isChanged;
        }

        private void UpdateDirtyState(string propertyName, object oldValue, object newValue)
        {
            // 避免無限遞迴：IsDirty 屬性本身的變更不需要追蹤
            if (propertyName == nameof(IsDirty))
                return;

            // 延遲初始化：只有在第一次修改時才建立字典
            if (_originalValues == null)
            {
                _originalValues = new Dictionary<string, object>();
            }

            // 如果這個屬性還沒被追蹤過，記錄它的原始值
            if (!_originalValues.ContainsKey(propertyName))
            {
                _originalValues[propertyName] = oldValue;
            }

            // 檢查新值是否等於原始值
            object originalValue = _originalValues[propertyName];

            if (Equals(originalValue, newValue))
            {
                // 改回原值了，移除追蹤
                _originalValues.Remove(propertyName);
            }

            // 更新 IsDirty 狀態
            bool currentDirtyState = _originalValues.Count > 0;

            if (!currentDirtyState)
            {
                _originalValues = null; // 釋放記憶體
            }

            // 直接設定 backing field 避免無限遞迴
            if (_isDirty != currentDirtyState)
            {
                _isDirty = currentDirtyState;
                RaisePropertyChanged(nameof(IsDirty));
            }
        }

        // 儲存成功後呼叫此方法，將目前狀態視為新的基準
        public void MarkAsClean()
        {
            _originalValues = null;
            IsDirty = false;
        }
    }
}
```

---

### 步驟 2：建立資料 ViewModel

讓您的資料物件繼承自 `TrackableBindableBase`。

```csharp
using YourProject.Core;

namespace YourProject.ViewModels
{
    public class CustomerViewModel : TrackableBindableBase
    {
        private string _name;
        public string Name
        {
            get { return _name; }
            set { SetProperty(ref _name, value); }
        }

        private int _age;
        public int Age
        {
            get { return _age; }
            set { SetProperty(ref _age, value); }
        }

        private string _email;
        public string Email
        {
            get { return _email; }
            set { SetProperty(ref _email, value); }
        }

        // 可以有任意多個屬性...
    }
}
```

---

### 步驟 3：在主 ViewModel 中使用

```csharp
using Prism.Commands;
using Prism.Mvvm;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Windows;
using System.Windows.Input;

namespace YourProject.ViewModels
{
    public class MainViewModel : BindableBase
    {
        public ObservableCollection<CustomerViewModel> Customers { get; set; }
        public ICommand SaveCommand { get; private set; }

        public MainViewModel()
        {
            Customers = new ObservableCollection<CustomerViewModel>();
            SaveCommand = new DelegateCommand(Save);
            
            // 載入資料後，記得呼叫 MarkAsClean()
            LoadDataFromDatabase();
        }

        private void LoadDataFromDatabase()
        {
            // 從 API 或資料庫載入資料
            var data = GetDataFromApi();
            
            foreach (var item in data)
            {
                var vm = new CustomerViewModel
                {
                    Name = item.Name,
                    Age = item.Age,
                    Email = item.Email
                };
                
                // 重要：標記為乾淨狀態
                vm.MarkAsClean();
                
                Customers.Add(vm);
            }
        }

        private void Save()
        {
            Stopwatch sw = Stopwatch.StartNew();
            
            // 高效能查詢：只找出被修改的資料
            var modifiedItems = Customers.Where(c => c.IsDirty).ToList();
            
            sw.Stop();

            if (modifiedItems.Count == 0)
            {
                MessageBox.Show($"沒有資料需要儲存。查詢耗時: {sw.ElapsedMilliseconds}ms");
                return;
            }

            // 呼叫 API 儲存資料
            SaveToApi(modifiedItems);

            MessageBox.Show($"已儲存 {modifiedItems.Count} 筆資料。查詢耗時: {sw.ElapsedMilliseconds}ms");

            // 儲存成功後，重置狀態
            foreach (var item in modifiedItems)
            {
                item.MarkAsClean();
            }
        }
    }
}
```

---

### 步驟 4：UI 視覺化回饋

在 XAML 中使用 `DataTrigger` 來改變被修改資料的背景色。

```xml
<DataGrid ItemsSource="{Binding Customers}" 
          AutoGenerateColumns="False"
          CanUserAddRows="False">
    
    <!-- 定義 Row 樣式 -->
    <DataGrid.RowStyle>
        <Style TargetType="DataGridRow">
            <Style.Triggers>
                <!-- 當 IsDirty 為 True 時，改變背景色 -->
                <DataTrigger Binding="{Binding IsDirty}" Value="True">
                    <Setter Property="Background" Value="#FFD1E8FF"/>
                    <Setter Property="FontWeight" Value="Bold"/>
                </DataTrigger>
            </Style.Triggers>
        </Style>
    </DataGrid.RowStyle>

    <DataGrid.Columns>
        <DataGridTextColumn Header="姓名" 
                            Binding="{Binding Name, UpdateSourceTrigger=PropertyChanged}" 
                            Width="*"/>
        <DataGridTextColumn Header="年齡" 
                            Binding="{Binding Age, UpdateSourceTrigger=PropertyChanged}" 
                            Width="100"/>
        <DataGridTextColumn Header="Email" 
                            Binding="{Binding Email, UpdateSourceTrigger=PropertyChanged}" 
                            Width="200"/>
        <DataGridCheckBoxColumn Header="已修改?" 
                                Binding="{Binding IsDirty, Mode=OneWay}" 
                                IsReadOnly="True" 
                                Width="80"/>
    </DataGrid.Columns>
</DataGrid>
```

---

## 效能分析

### 記憶體使用

| 狀態 | 記憶體佔用 |
|------|-----------|
| 未修改的物件 | `_originalValues = null`（幾乎無額外開銷） |
| 修改 1 個屬性 | `Dictionary` + 1 個 `KeyValuePair` |
| 修改後改回原值 | `Dictionary` 被釋放，回到初始狀態 |

**範例**：
- 100 萬筆資料，使用者只修改了 10 筆
- 額外記憶體：只有 10 個 `Dictionary` 實例
- 未修改的 999,990 筆：幾乎無額外開銷

### 查詢效能

使用 LINQ 的 `Where` 查詢，時間複雜度為 O(n)，但由於只是檢查布林值，速度非常快。

**實測數據**（10,000 筆資料）：
- 查詢修改項目：< 1ms
- 記憶體增長：可忽略不計

---

## 進階優化

### 1. 批次處理大量資料

如果需要一次載入數萬筆資料，建議分批處理以避免 UI 凍結：

```csharp
private async void LoadLargeDataset(int totalCount)
{
    int batchSize = 500;
    int batches = totalCount / batchSize;

    for (int batch = 0; batch < batches; batch++)
    {
        var batchData = await GetBatchDataAsync(batch, batchSize);
        
        await Application.Current.Dispatcher.InvokeAsync(() =>
        {
            foreach (var item in batchData)
            {
                item.MarkAsClean();
                Customers.Add(item);
            }
        });

        await Task.Delay(1); // 讓 UI 執行緒有機會處理其他事件
    }
}
```

### 2. 使用 HashSet 收集修改項目（可選）

如果資料量極大（百萬級），可以維護一個 `HashSet<T>` 來追蹤修改過的物件，避免每次都遍歷整個集合。

```csharp
private HashSet<CustomerViewModel> _modifiedItems = new HashSet<CustomerViewModel>();

// 在 CustomerViewModel 中加入事件
public event EventHandler BecameDirty;

// 在 UpdateDirtyState 中觸發
if (_isDirty != currentDirtyState && currentDirtyState)
{
    BecameDirty?.Invoke(this, EventArgs.Empty);
}

// 在主 ViewModel 中訂閱
foreach (var customer in Customers)
{
    customer.BecameDirty += (s, e) => _modifiedItems.Add((CustomerViewModel)s);
}
```

---

## 常見問題

### Q1: 為什麼不直接複製一份原始資料來比對？

**A**: 複製整份資料會讓記憶體使用量翻倍。例如 10 萬筆資料，每筆 1KB，就需要額外 100MB 記憶體。而使用本方案，只有被修改的資料才佔用額外記憶體。

### Q2: 如果屬性是複雜物件（如 List），怎麼辦？

**A**: `Equals` 方法對於參考型別只比較參考。如果需要深度比較，可以：
1. 實作自訂的 `IEquatable<T>`
2. 或在 `UpdateDirtyState` 中針對特定屬性做特殊處理

### Q3: 會不會影響效能？

**A**: 影響極小。每次屬性變更只增加：
- 1 次字典查詢（O(1)）
- 1 次 `Equals` 比較
- 可能的 1 次字典插入/刪除（O(1)）

---

## 總結

這個實作方案提供了：

✅ **自動化**：無需手動勾選，系統自動追蹤變更  
✅ **記憶體高效**：只有修改過的資料佔用額外記憶體  
✅ **還原偵測**：支援 A → B → A 的場景  
✅ **高效能**：適用於數萬至數十萬筆資料  
✅ **視覺化回饋**：透過 UI 樣式讓使用者清楚看到哪些資料被修改  

適用於各種需要批次編輯大量資料的 WPF 應用場景。
